<!DOCTYPE html>
<html lang="en">
<head>
    <title>Geothermieanlagen in Deutschland</title>
    <meta property="og:description" content="Übersichtskarte der Geothermieanlagen in Deutschland" />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css' />
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Titillium+Web:wght@400;600;700&display=swap" rel="stylesheet">
    <script src='https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.js'></script>
</head>
<body>
<h4>Tiefe Geothermie in Deutschland</h4>
<div id="map">
    <nav id="filter-group" class="filter-group">
        <h3>
            Filter nach Arten der Anlage
            <button id="toggle-filters" class="toggle-button">Filter Ausblenden</button>
        </h3>
        <div id="filters-content">
        </div>
    </nav>
</div>
<!-- Slideshow container -->
<div id="slideshow"></div>
<script>
     const filterGroup = document.getElementById('filter-group');
    const toggleButton = document.getElementById('toggle-filters');
    const filtersContent = document.getElementById('filters-content');
    const slideshow = document.getElementById('slideshow');
    
    const map = new maplibregl.Map({
        container: 'map',
        style: 'style.json',
        center: [10.00, 51.50],
        zoom: 3, 
        maxBounds: [[3.0, 47.0], [18.0, 56.0]] 
    });

    const iconColorMap = {
        'wärme': '#e51626',
        'wärme_strom': '#ff8c00',
        'strom': '#e1c200',
        'bau': '#025893',
        'planung': '#178009',
        'forschung': '#95338a'
    };

    const checkboxLabelMap = {
        'wärme_strom': 'Wärmebereitstellung und Stromerzeugung',
        'wärme': 'Wärmebereitstellung',
        'strom': 'Stromerzeugung',
        'bau': 'in Bau',
        'planung': 'in Planung',
        'forschung': 'Forschung',
    };

    // Slideshow implementation
    // TODO: change to load images dynamically
    /*const startSlideshow = () => {
        const imageFolder = './images/';
        const imageList = ['image1.jpg', 'image2.jpg', 'image3.jpg', 'image4.jpg', 'image5.jpg', 'image6.jpg', 'image7.jpg', 'image8.jpg', 'image9.jpg', 'image10.jpg'];
        const imagesPerGroup = 5;
        let currentIndex = 0;

        const updateSlideshow = () => {
            slideshow.innerHTML = '';

            for (let i = 0; i < imagesPerGroup; i++) {
                const imgIndex = (currentIndex + i) % imageList.length;
                const img = document.createElement('img');
                img.src = `${imageFolder}${imageList[imgIndex]}`;
                img.alt = `Slideshow image ${imgIndex + 1}`;
                img.className = 'slideshow-image';
                slideshow.appendChild(img);
            }

            currentIndex = (currentIndex + imagesPerGroup) % imageList.length;
        };

        updateSlideshow();
        setInterval(updateSlideshow, 5000);
    };
    
*/
const overlapThreshold = 100; // Define the threshold for overlapping points in meters

// Function to check if two points overlap
const arePointsOverlapping = (point1, point2) => {
    const lngLat1 = new maplibregl.LngLat(point1[0], point1[1]);
    const lngLat2 = new maplibregl.LngLat(point2[0], point2[1]);
    return lngLat1.distanceTo(lngLat2) < overlapThreshold;
};

// Function to highlight overlapping points
const highlightOverlappingPoints = (point1, point2) => {
    // Change the icon or add a border to indicate overlap
    const highlightColor = '#FF0000'; // Red color for overlapping points

    // You could change the icon color or add a border here based on the overlap
    map.setPaintProperty('poi-' + point1.icon, 'circle-color', highlightColor);
    map.setPaintProperty('poi-' + point2.icon, 'circle-color', highlightColor);
};
    map.on('load', () => {
        loadPlaces();
        startSlideshow();
    });
    let i = 0;
    const loadPlaces = async () => {
        try {
            const response = await fetch('anlagen_projektliste3.json');
            const places = await response.json();
            console.log('Loaded GeoJSON:', places);
            let points = [];
            places.features.forEach(feature => {
                const useTypes = feature.properties.state;
                console.log('Feature state:', feature.properties.state);


                if (useTypes.includes("Wärme & Strom")) {
                    feature.properties.icon = "wärme_strom";
                    i +=1;
                } else if (useTypes.includes("Wärme")) {
                    feature.properties.icon = "wärme";
                    i +=1;
                } else if (useTypes.includes("Strom")) {
                    feature.properties.icon = "strom";
                    i +=1;
                } else if (useTypes.includes("C_Forschungsprojekte ")) {
                    feature.properties.icon = "forschung";
                    i +=1;
                } else if (useTypes.includes("B_Projekt in Bau")) {
                    feature.properties.icon = "bau";
                    i +=1;
                } else if (useTypes.includes("D_Projekt in Planung")) {
                    feature.properties.icon = "planung";
                    i +=1;
                }
                points.push({
                coordinates: feature.geometry.coordinates,
                icon: feature.properties.icon,
                title: feature.properties.title
            });
            });
             // Store the point coordinates and icon for checking overlap
            
              // Check for overlapping points
            for (let i = 0; i < points.length; i++) {
                for (let j = i + 1; j < points.length; j++) {
                    const point1 = points[i];
                    const point2 = points[j];

                    if (arePointsOverlapping(point1.coordinates, point2.coordinates)) {
                        console.log(`${point1.title};${point1.coordinates[1]} ${point1.coordinates[0]}; \n${point2.title}; ${point2.coordinates[1]} ${point2.coordinates[0]};`);
                        //highlightOverlappingPoints(point1, point2);
                    }
                }
            }
            console.log('i:', i);
            map.addSource('places', {
                'type': 'geojson',
                'data': places
            });

            const filterTitle = document.createElement('h3');
            filterGroup.appendChild(filterTitle);

            Object.keys(iconColorMap).forEach((symbol) => {
                const layerID = `poi-${symbol}`;

                map.addLayer({
                    'id': layerID,
                    'type': 'circle',
                    'source': 'places',
                    'paint': {
                        'circle-color': iconColorMap[symbol],
                        'circle-radius': [
                            'interpolate',
                            ['linear'],
                            ['zoom'],
                            5, 4,
                            10, 12
                        ],
                        'circle-opacity': 0.8
                    },
                    'filter': ['==', ['get', 'icon'], symbol]
                });

                const input = document.createElement('input');
                input.type = 'checkbox';
                input.id = layerID;
                input.checked = true;
                filtersContent.appendChild(input);

                const label = document.createElement('label');
                label.setAttribute('for', layerID);
                const customCheckbox = document.createElement('span');
                customCheckbox.className = 'custom-checkbox';
                label.appendChild(customCheckbox);
                label.appendChild(document.createTextNode(checkboxLabelMap[symbol]));

                const colorIndicator = document.createElement('span');
                colorIndicator.className = 'color-indicator';
                colorIndicator.style.backgroundColor = iconColorMap[symbol];
                label.appendChild(colorIndicator);
                filtersContent.appendChild(label);

                input.addEventListener('change', (e) => {
                    map.setLayoutProperty(
                        layerID,
                        'visibility',
                        e.target.checked ? 'visible' : 'none'
                    );
                });
            });

            map.on('click', (e) => {
                const features = map.queryRenderedFeatures(e.point, { layers: map.getStyle().layers.map(layer => layer.id) });
                if (!features.length || !features[0].properties.title) return;

                const feature = features[0];
                const coordinates = feature.geometry.coordinates.slice();
                const title = feature.properties.title;
                const details = JSON.parse(feature.properties.details);
                const markerColor = iconColorMap[feature.properties.icon] || '#ffffff';
                let popupContent = `
                    <div style="background-color: ${markerColor}; color: white; padding: 5px; border-radius: 3px;">
                        <strong>${feature.properties.title}</strong>
                    </div>
                    <br>
                    <ul>`;

                if (details.Ptherm && details.Ptherm !== 'kein Eintrag') {
                    popupContent += `<li>Ptherm: ${details.Ptherm}</li>`;
                }
                if (details.Pel && details.Pel !== 'kein Eintrag') {
                    popupContent += `<li>Pel: ${details.Pel}</li>`;
                }
                if (details.Tmax && details.Tmax !== 'kein Eintrag') {
                    popupContent += `<li>Tmax: ${details.Tmax}</li>`;
                }
                if (details.Teufe && details.Teufe !== 'kein Eintrag') {
                    popupContent += `<li>Teufe: ${details.Teufe}</li>`;
                }
                if (details.Förderrate && details.Förderrate !== 'kein Eintrag') {
                    popupContent += `<li>Förderrate: ${details.Förderrate}</li>`;
                }
                if (details.Inbetriebnahme && details.Inbetriebnahme !== 'kein Eintrag') {
                    popupContent += `<li>Inbetriebnahme: ${details.Inbetriebnahme}</li>`;
                }

                popupContent += `</ul>`;

                new maplibregl.Popup()
                    .setLngLat(coordinates)
                    .setHTML(popupContent)
                    .addTo(map);
            });

            Object.keys(iconColorMap).forEach((symbol) => {
                const layerID = `poi-${symbol}`;
                map.on('mouseenter', layerID, () => {
                    map.getCanvas().style.cursor = 'pointer';
                });
                map.on('mouseleave', layerID, () => {
                    map.getCanvas().style.cursor = '';
                });
            });

        } catch (error) {
            console.error('Error loading places data:', error);
        }
    };

    map.on('load', () => {
        loadPlaces();
    });

    map.dragRotate.disable();
    map.touchZoomRotate.disableRotation();

    // Toggle filters visibility on button click
    toggleButton.addEventListener('click', () => {
        const isVisible = filtersContent.style.display === 'block';
        filtersContent.style.display = isVisible ? 'none' : 'block';
        toggleButton.textContent = isVisible ? 'Filter Anzeigen' : 'Filter Ausblenden'; 
    });
</script>
</body>
</html>
